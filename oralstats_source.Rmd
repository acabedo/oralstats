---
title: "Oralstats. Padre Zorro mod"
author: Adrián Cabedo Nebot
date: October 24, 2021
output: 
  html_document:
        highlight: tango
        number_sections: yes
        theme: simplex
        toc: yes
        toc_depth: 3
        toc_float:
          collapsed: yes
          smooth_scroll: yes
runtime: shiny
editor_options: 
  markdown: 
    wrap: 72
---

```{r global,cache=FALSE,include=FALSE,echo=FALSE}

library(MASS)
library(FactoMineR)
library(DT)
library(DBI)
library(RSQLite)
library(shinybusy)
library(psych)
library(shiny)
library(RColorBrewer)
library(tidyverse)
library(shinyWidgets)
library(tidytext)
library(readr)
library(heatmaply)
library(RLumShiny)
library(party)
library(gplots)
library(plotly)
library(gridExtra)
```

```{r data, cache=FALSE, include=FALSE}

ip <- readRDS(file = "ip.rds")
words <- readRDS(file = "words.rds")
phon <- readRDS(file = "phon.rds")
vowels <- readRDS(file = "vowels.rds")
intonational_phrase <- ip

mydb <- dbConnect(RSQLite::SQLite(), dbname = "prosody.sqlite")

res <- eventReactive(input$calcpitch,{
  qry <- paste0("SELECT * FROM prosody WHERE filename LIKE \'",input$pitchselname2,"\'"," AND Time_ms >",input$tminsel," AND Time_ms <", input$tmaxsel)
  res <- dbSendQuery(mydb,qry)
  dbFetch(res)
  })

options(shiny.maxRequestSize=100*1024^2)
```

Data proudly visualized with Oralstats.

# Info {.tabset .tabset-fade}

This dynamic dashboard has been generated using Rmarkdown and Shiny. It
presents a sample covering the speech analysis of an individual: the
youtuber named Padre Zorro/Pico de Oro. It presents speech
transcriptions along with some prosodic marks, mainly pitch and
intensity values, from two Youtube/Twitch monologues and one dialogue.

You need to press the FILTER/DEPLOY button to use and analyze this
dynamic speech data dashboard. By default, you'll see data of
intonational phrases, the most common speech unit, although you can
filter data in section 2 and explore other units like words or phonemes.

## About

Oralstats. Padre zorro mod.

*Versión beta: 1.0* (expect any kind of bugs)

Creator: Adrián Cabedo Nebot
([adrian.cabedo\@uv.es](adrian.cabedo@uv.es))

## Funded by

This project has been funded by three Spanish Research Projects:

Project: "La atenuación pragmática en su variación genérica: géneros
discursivos escritos y orales en el español de España y América"
(MICINN, FFI2016-75249-P). Directoras: Marta Albelda / Maria Estellés
(Departamento de Filología Española, UV). 2016-2021

Project: "Unidades discursivas para una descripción sistemática de los
marcadores del discurso en español" (UDEMADIS, FFI2016-77841-PP -
MICINN). Director: Salvador Pons Bordería (Departamento de Filología
Española, UV). 2016-2021

Project: ESPRINT. Estrategias pragmático-retóricas en la interacción
conversacional conflictiva entre íntimos y conocidos: intensificación,
atenuación y gestión interaccional. Ministerio de Ciencia e Innovación.
MICINN (PID2020-114895GB-10). 2021-

## License

As practically all the used libraries on Oralstats are GNU ([GNU General
Public License
v3.0](https://github.com/acabedo/oralstats/blob/main/LICENSE)), we use a
GNU license in our software.

## Requirements

If you download the code, you'll need most recent versions of libraries
(cited in credits section) along with RStudio and R installed on your
computer. <br/> If you prefer to use the web version, you'll just need a
common web browser like Google Chrome, Mozilla Firefox or Safari.
Although Oralstats can be launched on mobile devices, we recommend to
use a laptop or, at least, a bigger screen. This specific webpage,
uploaded to [shinyapps.io](shinyapps.io), is just an online sample done
for exemplification purposes.

# Begin here

In order to get speech analysis from this project, you can do two
operations:

1.  Select a speech unit (by default, *ip unit* is selected) and just
    press the button below. With that action you will get access to all
    the intonational phrases of this project, without any filtering.

2.  Select a speech unit (by default, *ip unit* is selected), select
    filters (6 different options available) and press button below. Then
    you will have a filtered data frame with your conditions. The last
    filter is an open box where you can use even regex expressions.

```{r inputpanel, include=TRUE,cache=FALSE, echo=FALSE, message=FALSE,warning=FALSE}

actionButton("filter","PRESS HERE TO DEPLOY OR FILTER CORPUS")

tags$table(
  
  tags$tr(tags$th(
pickerInput("units","Select units", choices = c("ip","words","phon") , options =  list(`actions-box` = FALSE),multiple = F, selected = "ip", width = "250px"))),

tags$tr(

tags$th(renderUI({
  p <- get(input$units)
varSelectInput("vars1", "Select filter 1", data = p[,-1]%>%select(where(is.character),where(is.factor)), width = "250px")})),

tags$th(renderUI({
   p <- get(input$units)
varSelectInput("vars2", "Select filter 2", data = p[,-1]%>%select(where(is.character),where(is.factor)),selectize = TRUE,width = "250px")})),

tags$th(renderUI({
   p <- get(input$units)
varSelectInput("vars3", "Select filter 3", data = p[,-1]%>%select(where(is.character),where(is.factor)),selectize = TRUE,width = "250px")}))),

tags$tr(

tags$th(renderUI({
   p <- get(input$units)
pickerInput("filter1", choices = unique(p[input$vars1]), options =  list(`actions-box` = TRUE),multiple = T, selected =NULL,width = "250px")})),

tags$th(renderUI({
   p <- get(input$units)
pickerInput("filter2", choices = unique(p[input$vars2]), options =  list(`actions-box` = TRUE),multiple = T, selected = NULL,width = "250px")})),

tags$th(renderUI({
   p <- get(input$units)
pickerInput("filter3", choices = unique(p[input$vars3]), options =  list(`actions-box` = TRUE,width = "150px"),multiple = T, selected = NULL,width = "250px")}))),

tags$tr(tags$th(tags$hr()),tags$th(tags$hr()),tags$th(tags$hr())),

tags$tr(

tags$th(renderUI({
   p <- get(input$units)
varSelectInput("vars4", "Select filter 4", data = p%>%select(where(is.numeric)),selectize = TRUE,width = "250px")})),

tags$th(renderUI({
   p <- get(input$units)
varSelectInput("vars5", "Select filter 5", data = p%>%select(where(is.numeric)),selectize = TRUE,width = "250px")})),

tags$th(renderUI({
   p <- get(input$units)
varSelectInput("vars6", "Select filter 6", data = p[,-1]%>%select(where(is.character),where(is.factor)),selectize = TRUE,width = "250px")}))),

tags$tr(

tags$th((renderUI({
   p <- get(input$units)
sliderInput("filter4","", min = min(p[input$vars4]), max = max(p[input$vars4]),value= c(min(ip[input$vars4]),max(ip[input$vars4])),width = "250px")})),


tags$th(renderUI({
   p <- get(input$units)
sliderInput("filter5","", min = min(p[input$vars5]), max = max(p[input$vars5]),value= c(min(ip[input$vars5]),max(ip[input$vars5])),width = "250px")}))),

tags$th(
  
  textInput("filter6", label = "",width = "250px")
  
  )))

```

```{r filtered, cache=FALSE,include=TRUE,echo=FALSE, message=FALSE,warning=FALSE}

filtered <- eventReactive(input$filter,{

  show_modal_spinner(
spin = "cube-grid",
color = "orange",
text = "Please wait...",
)
Sys.sleep(5)

   remove_modal_spinner() 
  
  
 p <- get(input$units) 
  filtered <- p %>% mutate(f1 = !!input$vars1, f2 = !!input$vars2, f3 = !!input$vars3, f4 = !!input$vars4, f5 = !!input$vars5, f6 = !!input$vars6)
   filtered <- if
    (input$filter6 == ""  & is.null(input$filter1) & is.null(input$filter2) & is.null(input$filter3) & is.null(input$filter4) & is.null(input$filter5))
    {filtered} else
      if
    (input$filter6 == ""  & !is.null(input$filter1) & is.null(input$filter2) & is.null(input$filter3) & !is.null(input$filter4) & !is.null(input$filter5))
    {filtered%>%filter(f1 %in% !!input$filter1,f4 >= !!input$filter4[1], f4 <= !!input$filter4[2],f5 >= !!input$filter5[1], f5 <= !!input$filter5[2])} else
    if
    (input$filter6 !=""  & is.null(input$filter1) & is.null(input$filter2) & is.null(input$filter3) & is.null(input$filter4) & is.null(input$filter5) )

    {filtered %>% filter(grepl(!!input$filter6,f6))}

      else
    if
    (input$filter6 !=""  & !is.null(input$filter1) & is.null(input$filter2)& is.null(input$filter3) & is.null(input$filter4) & is.null(input$filter5))

    {filtered %>% filter(grepl(!!input$filter6,f6), f1 %in% !!input$filter1)}

      else
     if   (input$filter6 !=""  & !is.null(input$filter1) & !is.null(input$filter2)& is.null(input$filter3) & is.null(input$filter4) & is.null(input$filter5))

     {filtered %>% filter(grepl(!!input$filter6,f6),f1 %in% !!input$filter1,f2 %in% !!input$filter2)}

 else
 if
         (input$filter6 !=""  & is.null(input$filter1) & !is.null(input$filter2)& is.null(input$filter3) & is.null(input$filter4) & is.null(input$filter5))

 {filtered %>% filter(grepl(!!input$filter6,f6), f2 %in% !!input$filter2)}
 else
   if
         (input$filter6 == ""  & !is.null(input$filter1) & is.null(input$filter2)& is.null(input$filter3) & is.null(input$filter4) & is.null(input$filter5))

   {filtered %>% filter(f1 %in% !!input$filter1)}
 else
      if
         (input$filter6 == ""  & !is.null(input$filter1) & !is.null(input$filter2)& is.null(input$filter3) & is.null(input$filter4) & is.null(input$filter5))

    {filtered %>% filter(f1 %in% !!input$filter1,f2 %in% !!input$filter2)}
        else

          if
         (input$filter6 == ""  & is.null(input$filter1) & !is.null(input$filter2)& is.null(input$filter3) & is.null(input$filter4) & is.null(input$filter5))

    {filtered %>% filter(f2 %in% !!input$filter2)}
        else
                  
             if
                   (input$filter6 !=""  & !is.null(input$filter1) & is.null(input$filter2)& is.null(input$filter3) & is.null(input$filter4) & is.null(input$filter5))

    {filtered %>% filter(grepl(!!input$filter6,f6),f1 %in% !!input$filter1 )}
          else
                         if
                   (input$filter6 !=""  & !is.null(input$filter1) & !is.null(input$filter2)& is.null(input$filter3) & is.null(input$filter4) & is.null(input$filter5))

    {filtered %>% filter(grepl(!!input$filter6,f6), f1 %in% !!input$filter1, f2 %in% !!input$filter2 )}
          else
                                     if
                   (input$filter6 == ""  & !is.null(input$filter1) & !is.null(input$filter2)& is.null(input$filter3) & is.null(input$filter4) & is.null(input$filter5))

    {filtered %>% filter(f1%in%!!input$filter1, f1 %in% !!input$filter2 )}
          else
                                                 if
                   (input$filter6 == ""  & is.null(input$filter1) & !is.null(input$filter2)& is.null(input$filter3) & is.null(input$filter4) & is.null(input$filter5))

    {filtered %>% filter(f2 %in% !!input$filter2 )}

          else
             if
                   (input$filter6 == ""  & !is.null(input$filter1) & is.null(input$filter2)& is.null(input$filter3) & is.null(input$filter4) & is.null(input$filter5))

             {filtered %>% filter(f1 %in% !!input$filter1 )}
 
           else
             if
                   (input$filter6 == ""  & is.null(input$filter1) & is.null(input$filter2)& is.null(input$filter3) & is.null(input$filter4) & !is.null(input$filter5))

    {filtered %>% filter(f5 >= !!input$filter5[1], f5 <= !!input$filter5[2] )}

          else
            if
                   (input$filter6 == ""  & is.null(input$filter1) & is.null(input$filter2)& is.null(input$filter3) & !is.null(input$filter4) & is.null(input$filter5))

    {filtered %>% filter(f4 >= !!input$filter4[1], f4 <= !!input$filter4[2] )}

          else
                        if
                   (input$filter6 == ""  & is.null(input$filter1) & is.null(input$filter2)& !is.null(input$filter3) & is.null(input$filter4) & is.null(input$filter5))

    {filtered %>% filter(f3%in%!!input$filter3 )}

          else
            if
                   (input$filter6 == ""  & is.null(input$filter1) & is.null(input$filter2)& is.null(input$filter3) & !is.null(input$filter4) & !is.null(input$filter5))

    {filtered %>% filter(f4 >= !!input$filter4[1], f4 <= !!input$filter4[2],f5 >= !!input$filter5[1], f5 <= !!input$filter5[2] )}

          else
                        if
                   (input$filter6 == ""  & is.null(input$filter1) & is.null(input$filter2)& !is.null(input$filter3) & !is.null(input$filter4) & !is.null(input$filter5))

    {filtered %>% filter(f4 >= !!input$filter4[1], f4 <= !!input$filter4[2],f5 >= !!input$filter5[1], f5 <= !!input$filter5[2] ,f3%in%input$filter3 )}

          else
               if
                   (input$filter6 == ""  & is.null(input$filter1) & !is.null(input$filter2)& !is.null(input$filter3) & !is.null(input$filter4) & !is.null(input$filter5))

    {filtered %>% filter(f4 >= !!input$filter4[1], f4 <= !!input$filter4[2],f5 >= !!input$filter5[1], f5 <= !!input$filter5[2] ,f3%in%input$filter3 ,f2%in%input$filter2 )}

          else
                           if
                   (input$filter6 == ""  & !is.null(input$filter1) & !is.null(input$filter2)& !is.null(input$filter3) & !is.null(input$filter4) & !is.null(input$filter5))

    {filtered %>% filter(f4 >= !!input$filter4[1], f4 <= !!input$filter4[2],f5 >= !!input$filter5[1], f5 <= !!input$filter5[2] ,f3%in%input$filter3 ,f2%in%input$filter2, f2%in%input$filter1 )}

          else
                                
                                                  if
                   (input$filter6 != ""  & !is.null(input$filter1) & !is.null(input$filter2)& !is.null(input$filter3) & !is.null(input$filter4) & !is.null(input$filter5))

    {filtered %>% filter(grepl(!!input$filter6,f6),f4 >= !!input$filter4[1], f4 <= !!input$filter4[2],f5 >= !!input$filter5[1], f5 <= !!input$filter5[2] ,f3%in%input$filter3,f2%in%input$filter2, f2%in%input$filter1 )}

          else
                                                            
                                                                          if
                   (input$filter6 != ""  & is.null(input$filter1) & !is.null(input$filter2)& !is.null(input$filter3) & !is.null(input$filter4) & !is.null(input$filter5))

    {filtered %>% filter(grepl(!!input$filter6,f6),f4 >= !!input$filter4[1], f4 <= !!input$filter4[2],f5 >= !!input$filter5[1], f5 <= !!input$filter5[2] ,f3%in%input$filter3 ,f2%in%input$filter2)}

          else
                                                                                      if
                   (input$filter6 != ""  & is.null(input$filter1) & is.null(input$filter2)& !is.null(input$filter3) & !is.null(input$filter4) & !is.null(input$filter5))

    {filtered %>% filter(grepl(!!input$filter6,f6),f4 >= !!input$filter4[1], f4 <= !!input$filter4[2],f5 >= !!input$filter5[1], f5 <= !!input$filter5[2] ,f3%in%input$filter3)}

          else
            if
                   (input$filter6 != ""  & is.null(input$filter1) & is.null(input$filter2)& is.null(input$filter3) & !is.null(input$filter4) & !is.null(input$filter5))

            {
                     filtered %>% filter(grepl(!!input$filter6,f6),f4 >= !!input$filter4[1], f4 <= !!input$filter4[2],f5 >= !!input$filter5[1], f5 <= !!input$filter5[2])
                   
                       }

          else
                       
          {filtered}

  })

briefselect <- reactive({briefselect <- filtered()%>%ungroup()%>%select(-f1,-f2,-f3,-f4,-f5,-f6)
briefselect})


```

# Brief summary {.tabset}

Just a little info on speech units in corpus. You have to select the
variable you want to get as a "group by" variable. The most common
action here is to select the speaker variable to observe the quantity of
speaker in the corpus. By default, speaker (spk) variable is selected
here.

```{r include= TRUE, echo=FALSE, message=FALSE,warning=FALSE}
renderUI({

varSelectInput("chosegroup","Select grouping variable", filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6)%>%select(where(is.character),where(is.factor)), selected = "spk", multiple = FALSE)})


actionButton("actchosegroup", "Create brief statistics")

briefselect2 <- eventReactive(input$actchosegroup, {briefselect2 <- filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6)%>%mutate(selection = !!input$chosegroup)
return(briefselect2)})

```

```{r include= TRUE, echo=FALSE, message=FALSE,warning=FALSE}

brief_units <- eventReactive(input$actchosegroup, {
   
  brief_units <- briefselect2()%>% group_by(selection)%>%summarise(cuenta=n())
  turnspielevel <-plot_ly(brief_units, labels = ~selection, values = ~cuenta, type = 'pie')

})

brief_units_total <- eventReactive(input$actchosegroup, {
   
  brief_units_total <- filtered()%>% summarise(cuenta=n())})

brief_words <- eventReactive(input$actchosegroup, {
  
  brief_words <- briefselect2() %>% group_by(selection)%>%summarise(cuenta=sum(qwords, na.rm = TRUE))
  turnspielevel <- plot_ly(brief_words, labels = ~selection, values = ~cuenta, type = 'pie')
  
})
brief_words_total <- eventReactive(input$actchosegroup, {
   
  brief_words_total <- briefselect2() %>% summarise(cuenta=sum(qwords,na.rm = TRUE))})

brief_types <- eventReactive(input$actchosegroup, {
  
  brief_types <- briefselect2() %>% group_by(selection)%>%summarise(cuenta=n_distinct(spk))
  turnspielevel <- plot_ly(brief_types, labels = ~selection, values = ~cuenta, type = 'pie')
  
})

brief_types_total <- eventReactive(input$actchosegroup, {
  
  brief_types <- briefselect2() %>%summarise(cuenta=n_distinct(spk))
  
})

```

## Speakers

In this subsection you can get the number of speakers or categories in
the selected grouping variable.

```{r include= TRUE, echo=FALSE, message=FALSE,warning=FALSE}

tags$strong("Total amount:")
renderPrint(brief_types_total()$cuenta)
renderPlotly(brief_types())


```

## Units

In this subsection you can get the number of speech units by speaker or
categories in the selected grouping variable.

```{r include= TRUE, echo=FALSE, message=FALSE,warning=FALSE}

tags$strong("Total amount:")
renderPrint(brief_units_total()$cuenta)
renderPlotly(brief_units())



```

## Words

In this subsection you can get the number of words by speaker or
categories in the selected grouping variable. Here you will need a
column called *quantity of words* (qwords) in order to get this
subsection properly working. So, if you select words or phonemes as data
frame to analyze, this subsections won't work.

```{r include= TRUE, echo=FALSE, message=FALSE,warning=FALSE}
tags$strong("Cantidad total")
  renderPrint(brief_words_total()$cuenta)
renderPlotly(brief_words())


```

# Crosstabs and chi square

This section will be active when you press filter or deploying button at
section 2. Then you will be able to observe the relationship between two
variables: first, with a crosstab table; second, with chi-square and
residuals. By default, speaker and filename variables are selected.

```{r crosstabs, echo=FALSE, warning=FALSE, message=FALSE}

tags$table(tags$tr(
  tags$th(renderUI(varSelectInput("cross1","Select first variable", data=filtered()%>%select(where(is.character),where(is.factor),-f1,-f2,-f3,-f4,-f5,-f6), selected = "spk"))),
  tags$th(renderUI(varSelectInput("cross2","Select second variable", data=filtered()%>%select(where(is.character),where(is.factor),-f1,-f2,-f3,-f4,-f5,-f6), selected = "file"))) ))

actionButton("cross3acts", "Show crosstabs")

crosstabs <- eventReactive(input$cross3acts, {
  
  p <- filtered()%>%select(where(is.character),where(is.factor)) %>% mutate(var1 = !!input$cross1, var2 = !!input$cross2)
    
    chisq.test(p$var1,p$var2)})

renderPrint(
 crosstabs()
  )
renderPrint(
 crosstabs()$observed
  )
renderPrint(
 crosstabs()$residuals
  )

```

# Concordances

If you search by conversation in section 2, it will appear a list of
concordances of speech unit selected and sorted by starting time. If you
do not filter by conversation, it will appear a list with all the
concordances of the speech unit selected.

```{r concordances, cache=FALSE, include=TRUE,echo=FALSE, message=FALSE,warning=FALSE}


renderUI(varSelectInput("selconc","Select variables", data = filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6), selected="spk", multiple = TRUE))

actionButton("showconc", "Show concordances")

showconc <- eventReactive(input$showconc, {
  
    show_modal_spinner(
spin = "cube-grid",
color = "orange",
text = "Please wait...",
)
Sys.sleep(4)

   remove_modal_spinner() 
  
  datatable({filtered()%>%ungroup()%>%select(!!!input$selconc)%>%mutate(across(where(is.numeric), ~ round(., 2)))},extensions = c('Buttons','FixedHeader'), options = list(search = list(regex = TRUE, caseInsensitive = FALSE),pageLength = 10,lengthMenu = c(1,5, 10, 15, 25, 50),scrollY="400px", scrollX=TRUE, dom = 'Bfrltip',
    buttons = c('copy', 'csv', 'excel')),filter="top"
                            )})
tags$div(renderDT(showconc()))

tags$div()

```

# Data

## Frequency {.tabset .tabset-fade}

### Most frequent units

In this subsection you can observe the most frequent units. One good
option here will be to put *annotation, token* or *phoneme,* depending
the unit data frame selected, in first filter and *speaker* (*spk*) in
second filter.

```{r include= TRUE, echo=FALSE, message=FALSE,warning=FALSE}

renderUI({varSelectInput("varsfreq","Select variable to quantify", data = filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6)%>%select(where(is.character),where(is.factor)),multiple = FALSE )})
renderUI({varSelectInput("varsfreq2","Select one variable to tag. For example, spk for speaker", data = filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6)%>%select(where(is.character),where(is.factor)),multiple = FALSE )})


actionButton("showfrequn", "Show frequent units")

showfrequn <- eventReactive(input$showfrequn, {filtered()%>%select(!!input$varsfreq2,!!input$varsfreq)%>%group_by(!!input$varsfreq2,!!input$varsfreq)%>%summarise(freq=n())%>%arrange(desc(freq))%>%head(n=10)})

renderDataTable(showfrequn(),options = list(
  pageLength = 5,
  lengthMenu = c(5, 10, 15, 20)
))

```

### Words/Tokens

This subsection will tokenize a specific variable. It is thought to work
properly better with bigger speech units, like intonational phrases or
speech turns.

```{r include= TRUE, echo=FALSE, message=FALSE,warning=FALSE}

renderUI({varSelectInput("varstok","Select variables to tokenize", data = filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6)%>%select(where(is.character),where(is.factor)),multiple = FALSE )})

actionButton("showfreqw", "Show frequent words")

showfreqw <- eventReactive(input$showfreqw, {filtered() %>% unnest_tokens(words,!!input$varstok,token="words")%>%group_by(words)%>%summarise(cantidad=n())%>%arrange(desc(cantidad))%>%filter(words!="")%>%head(n=10)})

renderDataTable(
  
 showfreqw(),options = list(
  pageLength = 5,
  lengthMenu = c(5, 10, 15, 20)
))

```

### Bigrams

This subsection will get bigrams for a specific variable. It is thought
to work properly better with bigger speech units, like intonational
phrases or speech turns.

**Note** It will take a while.

```{r include= TRUE, echo=FALSE, message=FALSE,warning=FALSE}

renderUI({varSelectInput("varsbig","Select variables to tokenize", data = filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6)%>%select(where(is.character),where(is.factor)),multiple = FALSE )})

actionButton("showfreqbig", "Show frequent bigrams")

showfreqbig <- eventReactive(input$showfreqbig, {
  
show_modal_spinner(
spin = "cube-grid",
color = "orange",
text = "Please wait...",
)
Sys.sleep(5)

   remove_modal_spinner() 
  filtered() %>% unnest_tokens(ngram,!!input$varsbig,token="ngrams", n=2)%>%group_by(ngram)%>%summarise(cantidad=n())%>%arrange(desc(cantidad))%>%filter(ngram!="")%>%head(n=10)
  

  })

renderDataTable(
 
  showfreqbig(),
  options = list(
  pageLength = 5,
  lengthMenu = c(5, 10, 15, 20)
))

```

### Trigrams

This subsection will get trigrams for a specific variable. It is thought
to work properly better with bigger speech units, like intonational
phrases or speech turns.

**Note** It will take a while.

```{r include= TRUE, echo=FALSE, message=FALSE,warning=FALSE}

renderUI({varSelectInput("varstri","Select variables to tokenize", data = filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6)%>%select(where(is.character),where(is.factor)),multiple = FALSE )})


actionButton("showfreqtrig", "Show frequent trigrams")

showfreqtrig <- eventReactive(input$showfreqtrig, {
  
  show_modal_spinner(
spin = "cube-grid",
color = "orange",
text = "Please wait...",
)
Sys.sleep(4)

   remove_modal_spinner() 
  
  filtered() %>% unnest_tokens(ngram,!!input$varstri,token="ngrams", n=3)%>%group_by(ngram)%>%summarise(cantidad=n())%>%arrange(desc(cantidad))%>%filter(ngram!="")%>%head(n=10)})

renderDataTable(
 
  showfreqtrig(),
  options = list(
  pageLength = 5,
  lengthMenu = c(5, 10, 15, 20)
))

```

## Sorted data

This section will get the 100 higher discourse units sorted by a numeric
selected variable. At second filter, you usually will want to filter by
annotation, token or phoneme. At third filter, you can use, for example,
speaker variable.

```{r include= TRUE, echo=FALSE, message=FALSE,warning=FALSE}

renderUI({
varSelectInput("sortvariable", "Select numeric variable", data = filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6)%>%select(where(is.numeric)),multiple = FALSE)})
renderUI({varSelectInput("sorttag","Select units", data = filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6)%>%select(where(is.character),where(is.factor)),multiple = FALSE )})
renderUI({varSelectInput("sorttag2","Select one variable to tag. For example, spk for speaker", data = filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6)%>%select(where(is.character),where(is.factor)),multiple = FALSE )})

actionButton("showpitchsort", "Show highest prosodic units")

showpitchsort <- eventReactive(input$showpitchsort, {filtered() %>% select(!!input$sorttag2, !!input$sorttag, !!input$sortvariable)%>% arrange(desc(!!input$sortvariable))%>%head(n=100)%>%mutate(across(where(is.numeric), ~ round(., 2)))})

renderDataTable(
 showpitchsort(),
  options = list(
  pageLength = 5,
  lengthMenu = c(5, 10, 15, 20),scrollX = TRUE
))

```

## Positions {.tabset .tabset-fade}

This section it is thought to work properly better with bigger speech
units, like intonational phrases and speech turns. It will get you the
most common first and last tokens and part of speech tags.

### Most first frequent word

```{r include= TRUE, echo=FALSE, message=FALSE,warning=FALSE}

renderDataTable(
 
  filtered() %>% mutate(first_words = `first(word)`)%>% group_by(first_words)%>%filter(!is.na(first_words)) %>% summarise(cantidad=n())%>%arrange(desc(cantidad))%>%head(n=10),
  options = list(
  pageLength = 5,
  lengthMenu = c(5, 10, 15, 20)
))
```

### Most last frequent word

```{r include= TRUE, echo=FALSE, message=FALSE,warning=FALSE}

renderDataTable(
 
  filtered() %>% mutate(last_words = `last(word)`)%>% group_by(last_words) %>%filter(!is.na(last_words))%>% summarise(cantidad=n())%>%arrange(desc(cantidad))%>%head(n=10),
  options = list(
  pageLength = 5,
  lengthMenu = c(5, 10, 15, 20)
))

```

### Most first frequent pos

```{r include= TRUE, echo=FALSE, message=FALSE,warning=FALSE}

renderDataTable(
 
  filtered() %>% mutate(first_upos = `first(upos)`)%>% group_by(first_upos) %>% summarise(cantidad=n())%>%arrange(desc(cantidad))%>%head(n=10),
  options = list(
  pageLength = 5,
  lengthMenu = c(5, 10, 15, 20)
))
```

### Most last frequent pos

```{r include= TRUE, echo=FALSE, message=FALSE,warning=FALSE}

renderDataTable(
 
  filtered()%>% mutate(last_upos = `last(upos)`) %>% group_by(last_upos) %>% summarise(cantidad=n())%>%arrange(desc(cantidad))%>%head(n=10),
  options = list(
  pageLength = 5,
  lengthMenu = c(5, 10, 15, 20)
))

```

## Average profile

This section will get the means from all numeric variables by a grouping
variable. The most general option here would be to select speaker column
at grouping variable.

```{r include= TRUE, echo=FALSE, message=FALSE,warning=FALSE}

renderUI(varSelectInput("averageprofile", "Select grouping variable", data = filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6)%>%select(where(is.character),where(is.factor))))

actionButton(inputId =  "avprofile", label =  "Create average profile")

avprofile <- eventReactive(input$avprofile, { 

filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6)%>%mutate(t=!!input$averageprofile)%>%group_by(t)%>%select(where(is.numeric),-tmin,-tmax)%>%summarise_if(is.numeric, ~round(mean(.,na.rm = TRUE),2), na.rm = TRUE)

})

tags$div(renderDataTable(avprofile(),options = list(scrollX = TRUE)))

```

# Inferential and exploratory statistics

## Descriptive statistics {.tabset}

Here you have to select a minimum of two numeric variables and a
grouping variable. Then you can get common descriptive statistics:
average, median, standard deviation...

```{r , include=TRUE,echo=FALSE, message=FALSE,warning=FALSE}
tags$table(tags$tr(tags$th(
renderUI({
varSelectInput("descr3", "Select variables", data = filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6)%>%select(where(is.numeric)),multiple = TRUE)})),
tags$th(
renderUI({
varSelectInput("descr1", "Select variable to explain", data = filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6)%>%select(where(is.character),where(is.factor)))})),
tags$th(
renderUI({
pickerInput("descr2","Select group", choices = unique(filtered()[input$descr1]), options =  list(`actions-box` = TRUE),multiple = T, selected = NULL)}))))

actionButton("descrbutton","Create summary statistics")
describee <- eventReactive(input$descrbutton, {

mapa <- briefselect()%>% mutate(t = !!input$descr1)%>% filter(t %in% !!input$descr2)%>% group_by(t) %>% select(t,!!!input$descr3)%>%ungroup()
  
describe(mapa%>%select(-t))})

renderDataTable(rownames_to_column(round(describee(),2)),options = list(
  pageLength = 5,
  lengthMenu = c(5, 10, 15, 20),scrollX = TRUE
))

```

## Anova {.tabset}

With ANOVA you can observe the statistical difference between groups on
a numeric variable. This subsection will give you the p values of these
relations and it will generate a boxplot chart in the frame below.

### Select

```{r anova_seleccion, include=TRUE,echo=FALSE, message=FALSE,warning=FALSE}


tags$table(tags$tr(tags$th(
renderUI({
varSelectInput("anova3", "Select numeric variable", data = filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6)%>%select(where(is.numeric)))})),
tags$th(
renderUI({
varSelectInput("anova1", "Select variable to explain", data = filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6)%>%select(where(is.character),where(is.factor)))})),
tags$th(
renderUI({
pickerInput("anova2","Select group", choices = unique(filtered()[input$anova1]), options =  list(`actions-box` = TRUE),multiple = T, selected = NULL)}))))
# selectizeInput("anova2", "Seleccionar grupo", choices = filtered()[input$anova1], selected = NULL, multiple = FALSE, options = NULL)
    # selectInput("anova2", "Seleccionar grupo", choices = filtered()[input$anova1], selectize = TRUE, multiple = TRUE)
  


# renderTable(head(filtered()%>% filter(!!input$anova1 %in% !!input$anova2)))
actionButton("anovabutton","Calculate ANOVA")

p <- eventReactive(input$anovabutton, {
  p <- filtered()%>% mutate(t = !!input$anova1, s = !!input$anova3)%>% filter(t %in% !!input$anova2)
                                                                              TukeyHSD(aov(s ~ t, data = p))})

anovaplot <- eventReactive(input$anovabutton,{
  p <- filtered()%>% mutate(t = !!input$anova1, s = !!input$anova3)%>% filter(t %in% !!input$anova2)
  
})
  

# renderPrint({
#   p <- filtered()%>% mutate(t = !!input$anova1, s = !!input$anova3)%>% filter(t %in% !!input$anova2)
# TukeyHSD(aov(s ~ t, data = p))}))

renderPrint(p())
renderPlotly({
  ggplot(anovaplot(), aes(x=t, y=s, fill=t)) + 
    geom_boxplot(alpha=0.3, outlier.shape = NA) +
    theme(legend.position="none")})
  

# renderPlotly(ggplot(filtered(), aes(x=get(input$anova3), y=get(input$anova1), fill=get(input$anova3))) + 
#     geom_boxplot(alpha=0.3, outlier.shape = NA) +
#     theme(legend.position="none"))

```

## Heatmap {.tabset}

In this subsection you can select a bunch of numeric variables and
explore the scaled values inside several selected groups. For example,
you can select pitch, intensity, pauses or speech rate and see the
difference among speakers.

```{r mapa_seleccion, include=TRUE,echo=FALSE, message=FALSE,warning=FALSE}


tags$table(tags$tr(tags$th(
renderUI({
varSelectInput("heat3", "Select predictors", data = briefselect()[-1]%>%select(where(is.numeric)),multiple = TRUE)})),
tags$th(
renderUI({
varSelectInput("heat1", "Select variable to explain", data = briefselect()[-1]%>%select(where(is.character),where(is.factor)))})),
tags$th(
renderUI({
pickerInput("heat2","Select group", choices = unique(filtered()[input$heat1]), options =  list(`actions-box` = TRUE),multiple = T, selected = NULL)}))))


actionButton(inputId =  "heatbutton", label =  "Create heatmap")

mapa <- eventReactive(input$heatbutton, { 

mapa <- briefselect()%>% mutate(t = !!input$heat1)%>% filter(t %in% !!input$heat2)%>% group_by(t) %>% select(t,!!!input$heat3) %>% summarize_if(., is.numeric, mean, na.rm = TRUE)
mapa2 <- mapa%>%select(-t)
rownames(mapa2) <- mapa$t
mapa <- as.matrix(mapa2)

})

mapa2 <- eventReactive(input$heatbutton, { 

mapa <- briefselect()%>% mutate(t = !!input$heat1)%>% filter(t %in% !!input$heat2)%>% group_by(t) %>% select(!!!input$heat3) %>% summarise(across(everything(), list(mean = mean,median=median, sd= sd),na.rm=TRUE))
mapa <- mapa %>% mutate_if(is.numeric, round, 2)

})

renderPlot(heatmap.2(mapa(), cexRow = 0.8 ,cexCol = 0.8, scale = "column"))
tags$br()
renderDT(mapa2(),rownames = TRUE,
  options = list(
  pageLength = 5,
  lengthMenu = c(5, 10, 15, 20),scrollX = TRUE
))

```

## Variables correlation {.tabset}

In this section you can create correlations between all the numeric
variables of the dataset. You will get a list with correlations.

```{r , include=TRUE,echo=FALSE, message=FALSE,warning=FALSE}
actionButton(inputId =  "corrbutton", label =  "Calculate correlations")


corr <- eventReactive(input$corrbutton, {
  mapa <-  filtered()[,-1] 
  mapa1 <- mapa %>%select(where(is.numeric),-tmin,-tmax)%>% drop_na()
corr<- cor(mapa1)})

tags$br()

tags$strong("Correlation values")

corr_values <- eventReactive(input$corrbutton, {
  mapa <-  get(input$units)
  mapa <- mapa 
  mapa1 <- mapa%>%select(where(is.numeric),-tmin,-tmax)%>% drop_na()
corr<- cor(mapa1)
})
renderDataTable(round(corr_values(),2), rownames=TRUE,options = list(
  pageLength = 5,
  lengthMenu = c(5, 10, 15, 20),scrollX = TRUE
))


```

## Decision tree {.tabset}

This method allows you to observe which variables and values can
discriminate better between groups. It will generate a decision tree
chart below.

```{r arbol_seleccion, include=TRUE,echo=FALSE, message=FALSE,warning=FALSE}


tags$table(tags$tr(tags$th(
renderUI({
varSelectInput("tree3", "Select predictors", data = filtered()[-1]%>%select(-f1,-f2,-f3,-f4,-f5,-f6)%>% mutate_if(is.character,as.factor),multiple = TRUE)})),
tags$th(
renderUI({
varSelectInput("tree1", "Select variable to explain", data = filtered()[,-1]%>%select(-f1,-f2,-f3,-f4,-f5,-f6)%>% mutate_if(is.character,as.factor))})),
tags$th(
renderUI({
pickerInput("tree2","Select group", choices = unique(filtered()[input$tree1]), options =  list(`actions-box` = TRUE),multiple = T, selected = NULL)}))))

actionButton("treebutton","Calculate decision tree")

ptree <- eventReactive(input$treebutton, {
  p <- filtered()%>% mutate_if(is.character,as.factor)%>% mutate(t = !!input$tree1)%>% filter(t %in% !!input$tree2)%>%select(t,!!!input$tree3)%>%droplevels()
  treeoutput <- ctree(as.factor(t)~., data = p, 
                      control = ctree_control(maxdepth = 3))
  plot(treeoutput)                               
  })


renderPlot(ptree())


```

## Discriminant analysis

When you have more than two categories on a categorical variable, you
can use discriminant analysis as an evolution of binary logistic
regression. It's simply a technique to reduce the explanatory variables
and values on a data set.

```{r lda, include=TRUE,echo=FALSE, message=FALSE,warning=FALSE}
tags$table(tags$tr(tags$th(
renderUI({
varSelectInput("lda3", "Select dependent variable", data = filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6),multiple = TRUE)})),
tags$th(
renderUI({
varSelectInput("lda1", "Select independent variable", data = filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6))})),
tags$th(
renderUI({
pickerInput("lda2","Select group", choices = unique(filtered()[input$lda1]), options =  list(`actions-box` = TRUE),multiple = T, selected = NULL)}))))

actionButton("ldabutton","Calculate discriminant analysis")

lineartest <- eventReactive(input$ldabutton, {
  p <- filtered()%>% mutate(t = as.factor(!!input$lda1))%>% filter(t %in% !!input$lda2)%>%select(t,!!!input$lda3)
  ldaoutput <- lda(as.factor(t)~., data = p)
ldaoutput

})

renderPrint(lineartest())

linearpredict <- eventReactive(input$ldabutton, {
  p <- filtered()%>% mutate(t = !!input$lda1)%>% filter(t %in% !!input$lda2)%>%select(t,!!!input$lda3)
  ldaoutput <- lda(as.factor(t)~., data = p)
p2 <- predict(ldaoutput, p)$class
tab1 <- table(Predicted = p2, Actual = p$t)
tab1


})

linearpredict2 <- eventReactive(input$ldabutton, {
  p <- filtered()%>% mutate(t = !!input$lda1)%>% filter(t %in% !!input$lda2)%>%select(t,!!!input$lda3)
  ldaoutput <- lda(as.factor(t)~., data = p)
p2 <- predict(ldaoutput, p)$class
tab1 <- table(Predicted = p2, Actual = p$t)
tab1
sum(diag(tab1))/sum(tab1)

})

renderPrint(linearpredict())
renderPrint(linearpredict2())

```

## Principal component analysis

PCA is a technique similar to discriminant analysis, but its main
difference is that the groups are not defined previously. Nevertheless,
you can select a coloring variable below to project near and far values
among records of data set.

```{r pca, echo=FALSE,warning=FALSE}

tags$table(tags$tr(tags$th(
renderUI({
varSelectInput("pca1", "Select numeric variables", data = filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6),multiple = TRUE)})),
tags$th(
renderUI({
varSelectInput("pca2", "Select categorical variable", data = filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6))})),
tags$th(
renderUI({
pickerInput("pca3","Select group", choices = unique(filtered()[input$pca2]), options =  list(`actions-box` = TRUE),multiple = T, selected = NULL)}))))

actionButton("pcabutton","Calculate pca analysis")

pcatest <- eventReactive(input$pcabutton, {

  res.pca = PCA(filtered()%>% mutate(p = !!input$pca2)%>%select(!!!input$pca1,p)%>%filter(p %in% !!input$pca3)%>%relocate(p)%>%drop_na(), scale.unit=TRUE, ncp=5, quali.sup=1, graph=T)

})


renderPlot({
  
  plot(pcatest(), axes=c(1, 2), choix="ind", habillage=1)
  
})

renderPrint({
  
  
  dimdesc(pcatest(),axes=c(1,2))
  
})

```

# Explore prosody

## Pitch and Intensity raw data

In this subsection you must select a filename variable and then you will
be able to access pitch (semitones) and intensity from raw data. In the
frame below, you will also see a data frame with the speech unit (or
units) that coincide with beginning and ending times selected.

```{r prosodia_seleccion,cache=FALSE,echo=FALSE, message=FALSE,warning=FALSE}


tags$table(tags$tr(tags$th(
tags$div(renderUI({
p <- get(input$units)
varSelectizeInput("pitchselname1","Select filename variable", p%>%select(where(is.character),where(is.factor)), multiple = FALSE)
}))),

tags$th(renderUI({
pickerInput("pitchselname2","Select specific file", choices = unique(filtered()[input$pitchselname1]), options =  list(`actions-box` = TRUE),multiple = F, selected = NULL)}))),
tags$tr(tags$th(tags$div(sliderInput("tminsel","Begin time",0,200000,step = 50,value = 0))),
tags$th(tags$div(sliderInput("tmaxsel","Ending time",0,200000,step=50, value= 1000)))))

tags$div(actionButton(inputId = "calcpitch", label = "Create pitch"))

renderPlotly ({
  pitch <- res()
  ggplot(data=pitch, aes(x=Time_ms))+ geom_point(aes(y = st), color = "blue")+ geom_point(aes(y = Intensity), color="green", linetype="twodash") + ylim(0,120)

  })
renderUI(varSelectInput("selconc2","Select variables to show on time selected",data = filtered()%>%select(-f1,-f2,-f3,-f4,-f5,-f6), multiple = TRUE))
anot_select <- reactive(filtered() %>%mutate(tmin_ms= tmin*1000, tmax_ms = tmax*1000)%>% filter(!!input$pitchselname1==!!input$pitchselname2,tmin_ms > !!input$tminsel, tmax_ms < !!input$tmaxsel)%>% arrange(!!input$pitchselname1,tmin)%>%select(!!!input$selconc2))
renderDataTable(anot_select(), options = list(pageLength = 5, lengthMenu = c(5, 10, 15, 20), scrollX = TRUE))



```

## Prosodic flow and average contrast

As the name of the subsection says, here you can observe the behavior of
a numeric variable and its relation with a horizontal line reflecting
the mean of this variable along time. At the frame below, you will see a
mean for all the corpus and for specific categories (or speakers) on the
analyzed file.

```{r lolipop_seleccion,echo=FALSE, message=FALSE,warning=FALSE}
tags$table(tags$tr(tags$th(
tags$div(renderUI({
p <- get(input$units)
varSelectizeInput("lolipop1","Select filename variable", p%>%select(where(is.character),where(is.factor)), multiple = FALSE)
}))),

tags$th(renderUI({
pickerInput("lolipopgroup","Select specific file", choices = unique(filtered()[input$lolipop1]), options =  list(`actions-box` = TRUE),multiple = F, selected = NULL)}))),

tags$tr(tags$th(tags$div(renderUI({
p <- get(input$units)

varSelectizeInput("lolipop2","Select numeric variable", p%>%select(where(is.numeric)), multiple = FALSE)
}))),

tags$th(tags$div(renderUI({
p <- get(input$units)

varSelectizeInput("lolipopcat","Select categorical variable", p%>%select(where(is.character),where(is.factor)), multiple = FALSE)
})))))

actionButton(inputId =  "melodybutton", label =  "Show map")

melodyavgplot <- eventReactive(input$melodybutton, {
  p <- get(input$units)
  dataframe <- p%>% filter(!!input$lolipop1%in%!!input$lolipopgroup)%>% mutate(selection = !!input$lolipop2, selection2 = !!input$lolipopcat) 
  
  ggplot(dataframe, aes(x=tmin, y=selection,color=selection2)) +
    geom_segment(aes(x=tmin, xend=tmin, y=mean(selection,na.rm=TRUE), yend=selection), color="grey") +
    geom_point (size=4) +
    theme_light() +
    theme(
        panel.grid.major.x = element_blank(),
        panel.border = element_blank(),
        axis.ticks.x = element_blank()
    ) +
    xlab("") +
    ylab("Prosodic variable")})

mean_deviance_gen <- eventReactive(input$melodybutton, {

filtered()%>%filter(!!input$lolipop1 %in% !!input$lolipopgroup)%>%summarise(mean = mean(!!input$lolipop2, na.rm=TRUE), SD = sd(!!input$lolipop2, na.rm=TRUE))

  
})

mean_deviance_speaker <- eventReactive(input$melodybutton, {

filtered()%>%filter(!!input$lolipop1 %in% !!input$lolipopgroup)%>%group_by(!!input$lolipopcat) %>% summarise(mean = mean(!!input$lolipop2, na.rm=TRUE), SD = sd(!!input$lolipop2, na.rm=TRUE))

  
})

renderPlotly(melodyavgplot())

tags$strong("General mean (from all speakers; speaker must be not filtered in Section 2)")
renderTable(mean_deviance_gen())
tags$strong("Mean for each speaker")
renderTable(mean_deviance_speaker())

```

## Pitch contour visualization

In order to get this section working properly well you have to be sure
that you are using a vowels data frame correctly transformed with
oralstats.create. This dataframe is not selectable on filtering options
at Section 2, it should be uploaded at the beginning of the script.
Generally, it presents a more advanced pitch visualization that pitch
raw data; it depends deeply on pitch transformations and taggings done
following two pitch annotation systems: SP-TOBI (Prieto & Estebas 2008)
and MHA (Cantero & Font 2012), but it also takes the acoustic values of
vowels. TOBI value is computed in *stressed* variable and MHA on AMH3
variable. The first one is categorical and it can be selected on *Select
text variable*; the latter is numeric, and it can be uploaded to Select
y variable.

If you just want to observe the sample without changing any value, just
change Select group filter to navigate among intonational phrases id.
For each unit, you will get the *stylized* contour. From that, you can
change other variables, like y variable, for example, and observe the
intensity values on same vowels.

The initial configuration will put a color for each word inside
intonational phrase, the y values will be the pitch on semitones, x
value will represent time and also it will be an additional intensity
value. This will be projected on the size of the circular points at
vowels.

```{r contsel, echo=FALSE}

tags$table(
  
  tags$tr(tags$th(
renderUI({

varSelectInput("cont1","Select unit variable", vowels%>%select(where(is.character)), multiple = FALSE, selected="ip_id", width = "250px")
})),

tags$th(
tags$div(renderUI({
pickerInput("cont2","Select group", choices = unique(vowels[input$cont1]), options =  list(`actions-box` = TRUE),multiple = F, selected = NULL, width = "250px")}))),

tags$th(tags$div(renderUI({

varSelectizeInput("cont3","Select x variable", vowels%>%select(where(is.numeric)), multiple = FALSE, selected="tmin", width = "250px")
})))),

  tags$tr(tags$th(tags$div(renderUI({varSelectizeInput("cont4","Select y variable", vowels%>%select(where(is.numeric)), multiple = FALSE, selected = "PimnSt", width = "250px")
}))),

tags$th(tags$div(renderUI({

varSelectizeInput("cont5","Select linetype variable", vowels%>%select(where(is.character),where(is.factor)), multiple = FALSE,selected="w_id", width = "250px")
}))),

tags$th(tags$div(renderUI({

varSelectizeInput("cont6","Select factor variable", vowels%>%select(where(is.character),where(is.factor)), multiple = FALSE, selected="w_id", width = "250px")
})))),

  tags$tr(tags$th(tags$div(renderUI({

varSelectizeInput("cont7","Select size variable", vowels%>%select(where(is.numeric)), multiple = FALSE, selected="Imn", width = "250px")
}))),

tags$th(tags$div(renderUI({

varSelectizeInput("cont8","Select text variable", vowels%>%select(where(is.character),where(is.factor)), multiple = FALSE, selected="phon", width = "250px")
}))),
tags$th(tags$div(renderUI({

varSelectizeInput("cont9","Select text variable", vowels%>%select(where(is.character),where(is.factor)), multiple = FALSE, selected="ip", width = "250px")
})))))

actionButton(inputId =  "contplot", label =  "Show chart")

tags$div(renderUI({

varSelectizeInput("cont10","Select variables to show", vowels%>%select(where(is.character),where(is.factor)), multiple = TRUE)
}))
actionButton(inputId =  "contDT", label =  "Show table")


melodyplot <- eventReactive(input$contplot, {
dataframe <- vowels%>% filter(!!input$cont1%in%!!input$cont2)%>%arrange(!!input$cont3)%>% mutate(xaxe = !!input$cont3, yaxe = !!input$cont4, linety = !!input$cont5, factormel = !!input$cont6, sizemel = !!input$cont7, textcolap = !!input$cont8, wrapping = !!input$cont9)

ggplot(data=dataframe, aes(x=xaxe, y=yaxe, linetype=linety)) +
  geom_line(color="black", size=1)+
  geom_point(aes(colour = factor(factormel), size=sizemel))+
  geom_text(aes(label=textcolap)) + facet_wrap(~str_wrap(wrapping)) })

dataframemel <- eventReactive(input$contDT, {
dataframe <- vowels%>% filter(!!input$cont1%in%!!input$cont2)%>%arrange(!!input$cont3)%>% mutate(xaxe = !!input$cont3, yaxe = !!input$cont4, linety = !!input$cont5, factormel = !!input$cont6, sizemel = !!input$cont7, textcolap = !!input$cont8, wrapping = !!input$cont9)%>%select(!!!input$cont10)
 })


renderDataTable(head(dataframemel()))

renderPlotly(melodyplot())

```

# Credits {.tabset}

## R packages

```{r credits, include=TRUE,cache=FALSE,echo=FALSE, message=FALSE,warning=FALSE}

tags$strong("Dplyr")
tags$div(renderPrint(
{citation("dplyr")}))
tags$strong("Tidyverse")
tags$div(renderPrint(
{citation("tidyverse")}))
tags$strong("Tidyr")
tags$div(renderPrint({
citation("tidyr")}))
tags$strong("UdPipe")
tags$div(renderPrint(
{citation("udpipe")}))
tags$strong("MASS")
tags$div(renderPrint(
{citation("MASS")}))
tags$strong("DT")
tags$div(renderPrint(
{citation("DT")}))
tags$strong("DBI")
tags$div(renderPrint(
{citation("DBI")}))
tags$strong("shinybusy")
tags$div(renderPrint(
{citation("shinybusy")}))
tags$strong("psych")
tags$div(renderPrint(
{citation("psych")}))
tags$strong("shiny")
tags$div(renderPrint(
{citation("shiny")}))
tags$strong("RColorBrewer")
tags$div(renderPrint(
{citation("RColorBrewer")}))
tags$strong("shinyWidgets")
tags$div(renderPrint(
{citation("shinyWidgets")}))
tags$strong("tidytext")
tags$div(renderPrint(
{citation("tidytext")}))
tags$strong("heatmaply")
tags$div(renderPrint(
{citation("heatmaply")}))
tags$strong("party")
tags$div(renderPrint(
{citation("party")}))
tags$strong("gplots")
tags$div(renderPrint(
{citation("gplots")}))
tags$strong("plotly")
tags$div(renderPrint(
{citation("plotly")}))


```

## Software used

Practically all the data files needed to work with Oralstats come from
the usage of two main programs: PRAAT and ELAN.

<a href="https://www.fon.hum.uva.nl/praat/">PRAAT</a> <br/>
<a href="https://archive.mpi.nl/tla/elan/">ELAN</a>

## Inspirational corpus platforms and systems

Here you will find a list of corpus platforms that have inspired the
creation of Oralstats. Sometimes it could be the disposal of the
webpage, other times it could be the database infrastructure. We want to
give some credit to these previous works because they were a basis for
our work.

<a href="https://github.com/radiant-rstats/radiant">Radiant</a><br/>
<a href="https://www.corpusdelespanol.org/">Corpus del español</a> <br/>
<a href="http://spokes.clarin-pl.eu/">Spokes</a> <br/>
<a href="http://eslora.usc.es/">Eslora</a> <br/>
<a href="https://cqpweb.lancs.ac.uk/">CQPWeb</a> <br/>
<a href="http://stel3.ub.edu/labfon/amper/eti_ToBI/">ETITOBI</a>

# Acronyms developed {.tabset .tabset-fade}

Here you will find a list with the short version of the variables
developed.

## Ip variables

1.  ip_id. Unique identification for every intonational phrase.
2.  tmin. Beginning time of the ip.
3.  tmax. Ending time of the ip.
4.  dur. Duration in seconds of the ip.
5.  corpus. A variable with only one variant, "corpus", generated to
    compute overall frequencies and means for all the dataframe.
6.  annotation. The transcribed text of the ip.
7.  file. A filename.
8.  spk. Speaker.
9.  qwords. Quantity of words inside the ip.
10. phonemes. Quantity of phonemes inside the ip.
11. first(word). First word of the ip.
12. last(word). Last word of the ip.
13. first(upos). First part of speech for the first word of the ip.
14. last(upos). Last part of speech tag for the last word of the ip..
15. s_rate. Speech rate measured (number of words per second).
16. declination. Overall Rising or falling pitch movement from the
    beginning to the ending of the ip.
17. qadv. Quantity of adverbs.
18. qnoun. Quantity of nouns.
19. qverb. Quantity of verbs.
20. qdet. Quantity of determinants.
21. qpron. Quantity of pronouns.
22. qadj. Quantity of adjectives.
23. qconj. Quantity of conjunctions.
24. qangry. Quantity of angry words.
25. qsadness. Quantity of sadness words.
26. qhappy. Quantity of happy words.
27. qpos. Quantity of positive words.
28. qneg. Quantity of negative words.
29. qfear. Quantity of fear words.
30. qnasty. Quantity of nasty words.
31. stressed. TOBI tag for the last stressed syllable of the ip.
32. bound. TOBI tag for the last stressed syllable of the ip.
33. ipdecl. Overall Rising or falling pitch movement from the first
    vowel to the last vowel of the ip.
34. firstHz. First Hz value of the ip.
35. midHz. Middle Hz value of the ip.
36. lastHz. Last Hz value of the ip.
37. firstSt. First St value of the ip.
38. midSt. Middle St value of the ip.
39. lastSt. Last St value of the ip.
40. PirHz. Pitch range in Hz.
41. PirSt. Pitch range in St.
42. Pimd. Pitch median in Hz.
43. PimnHz. Pitch average in Hz.
44. PimnSt. Pitch average in St.
45. Imd. Intensity median in dB.
46. Imn. Intensity mean ind dB.
47. trpr. Duration of the transition from the previous ip.
48. trpst. Duration of the transition from the posterior ip.
49. RdprSt. Range difference in semitones from the previous ip.
50. Idpr. Intensity difference in dB from the previous ip.
51. spkpr. The ip of the previous speaker is the same or other speaker.
52. spkpst. The ip of the posterior speaker is the same or other
    speaker.
53. ppr. Duration of the previous pause (same speaker before).
54. ppst. Duration of the posterior pause (same speaker after).
55. ftopr. Duration of the previous pause (different speaker before).
56. ftopst. Duration of the posterior pause (different speaker before).
57. Rdspk. Difference with the average pitch range of the speaker.
58. Idspk. Difference with the average intensity of the speaker.
59. PdspkHz. Difference with the average pitch in Hz of the speaker.
60. PdspkSt. Difference with the average pitch in St of the speaker.
61. PidprSt. Pitch difference with previous ip in semitones.

## Words variables

1.  w_id. Unique identification for every word.
2.  tmin. Beginning time of the word.
3.  tmax. Ending time of the word.
4.  dur. Duration in seconds of the word.
5.  corpus. A variable with only one variant, "corpus", generated to
    compute overall frequencies and means for all the dataframe.
6.  token. The transcribed text of the word.
7.  file. A filename.
8.  spk. Speaker.
9.  qphonemes. Quantity of phonemes inside the word. first(word).
10. fph. First phoneme of the word.
11. lstph. Last phoneme of the word.
12. s_rate. Speech rate measured (number of phonemes per second).
13. declination. Overall Rising or falling pitch movement from the
    beginning to the ending of the word.
14. upos. Part of speech tag.
15. lemma. Lemma of the word.
16. sentiment. Sentiment tag using Tidyverse approach.
17. TOBI. TOBI tag for the last stressed syllable of the word.
18. bound. TOBI tag for the last stressed syllable of the word.
19. toneme. Whether the word is an ending word of the intonational
    phrase or not.
20. tonic. Whether the word is a tonic word or not.
21. PirHz. Pitch range in Hz.
22. PirSt. Pitch range in St.
23. Pimd. Pitch median in Hz.
24. PimnHz. Pitch average in Hz.
25. PimnSt. Pitch average in St.
26. Imd. Intensity median in dB.
27. Imn. Intensity mean ind dB.
28. trpr. Duration of the transition from the previous word.
29. trpst. Duration of the transition from the posterior word.
30. RdprSt. Range difference in semitones from the previous word.
31. Idpr. Intensity difference in dB from the previous word.
32. spkpr. The word of the previous speaker is the same or other
    speaker.
33. spkpst. The word of the posterior speaker is the same or other
    speaker.
34. ppr. Duration of the previous pause (same speaker before).
35. ppst. Duration of the posterior pause (same speaker after).
36. Rdspk. Difference with the average pitch range of the speaker.
37. Idspk. Difference with the average intensity of the speaker.
38. PdspkHz. Difference with the average pitch in Hz of the speaker.
39. PdspkSt. Difference with the average pitch in St of the speaker.
40. ip_id. Id of the intonational phrase to which the word belongs.
41. annotation. Text of the intonational phrase to which the word
    belongs.

## Phonemes variables

1.  ph_id. Unique identification for every intonational phrase.
2.  tmin. Beginning time of the word.
3.  tmax. Ending time of the word.
4.  dur. Duration in seconds of the word.
5.  corpus. A variable with only one variant, "corpus", generated to
    compute overall frequencies and means for all the dataframe.
6.  phoneme. The transcribed text of the phoneme.
7.  phon_type. The phoneme can be a vowel, a consonante or a glide.
8.  file. A filename.
9.  spk. Speaker.
10. firstHz. First value of the phoneme in Hz.
11. midHz. Middle value of the phoneme in Hz.
12. lastHz. Last value of the phoneme in Hz.
13. firstSt. First value of the phoneme in St.
14. midSt. Middle value of the phoneme in Hz.
15. lastSt. Last value of the phoneme in Hz.
16. tonic. Whether the phoneme is a tonic vowel or not.
17. PirHz. Pitch range in Hz.
18. PirSt. Pitch range in St.
19. Pimd. Pitch median in Hz.
20. PimnHz. Pitch average in Hz.
21. PimnSt. Pitch average in St.
22. Imd. Intensity median in dB.
23. Imn. Intensity mean ind dB.
24. trpr. Duration of the transition from the previous word.
25. trpst. Duration of the transition from the posterior word.
26. RdprSt. Range difference in semitones from the previous word.
27. Idpr. Intensity difference in dB from the previous word.
28. spkpr. The word of the previous speaker is the same or other
    speaker.
29. spkpst. The word of the posterior speaker is the same or other
    speaker.
30. ppr. Duration of the previous pause (same speaker before).
31. ppst. Duration of the posterior pause (same speaker after).
32. Rdspk. Difference with the average pitch range of the speaker.
33. Idspk. Difference with the average intensity of the speaker.
34. PdspkHz. Difference with the average pitch in Hz of the speaker.
35. PdspkSt. Difference with the average pitch in St of the speaker.
36. ip_id. Id of the intonational phrase to which the word belongs.
37. ip. Text of the intonational phrase to which the word belongs.
38. ip_dur. Duration of the intonational phrase.
39. ip_tmin. Begin time ot the intonational phrase.
40. ip_tmax. Ending time of the intonational phrase.
41. w_id. Id of the intonational phrase to which the word belongs.
42. word. Text of the word.
43. w_dur. Duration of the word.
44. w_tmin. Begin time of the word.
45. w_tmax. Ending time of the word.
46. upos. Part of speech tag of the word.
47. lemma. Lemma of the word.
48. orderinword. Order of the phoneme in the word.
49. orderinip. Order of the phoneme in the ip.
50. corresp_w\_ip. Temporal correspondence between word and ip.

# Note

Data used for this sample research comes from Youtuber Pico de Oro/Padre
zorro and from his two channels: [Pico de
oro](https://www.youtube.com/channel/UC4oGsbaR87FQ1b3C04ZxVwQ/featured)
and [Padre
Zorro](https://www.youtube.com/channel/UCyCPV3dynWRlH4exaqgwEWw), all
the rights belongs to his author and I am using them only with
scientific purposes. This data was transcribed with ELAN and aligned to
words and phonemes with PRAAT. This last alignment was partially
automated, so you should expect some errors that could affect TOBI
tagging.

Data was transformed with Oralstats.create and this dynamic dashboard
has been generated with Oralstats.view. Both scripts can be found at
<https://github.com/acabedo/oralstats>
